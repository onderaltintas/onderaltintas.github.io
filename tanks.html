<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Triangle Tanks</title>
<style>
  html,body{height:100%;margin:0;background:#111}
  canvas{display:block;margin:auto; background:#222; image-rendering: optimizeSpeed;}
</style>
</head>
<body>
<canvas id="c" width="1024" height="1024"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const NUM = 3500 + Math.floor(Math.random()*101); // 500-600
const tanks = [];
const shots = [];

function rand(min, max){ return Math.random()*(max-min)+min; }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function angleBetween(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }

class Tank{
  constructor(){
    this.x = rand(0, W);
    this.y = rand(0, H);
    this.size = rand(6,12); // triangle size (radius)
    this.color = `hsl(${Math.floor(rand(0,360))},${randInt(50,85)}%,${randInt(40,65)}%)`;
    this.angle = rand(0, Math.PI*2);
    this.speed = rand(0.25, 1.0);
    this.turnSpeed = rand(0.01, 0.05);
    this.target = this.newTarget();
    this.fireCooldown = rand(0, 60); // frames
    this.fireRate = randInt(30, 120);
    this.alive = true;
    this.id = Math.random().toString(36).slice(2,9);
  }
  newTarget(){ return {x: rand(0,W), y: rand(0,H)}; }
  update(){
    if(!this.alive) return;
    // move towards target
    const desired = angleBetween(this, this.target);
    let a = desired - this.angle;
    a = Math.atan2(Math.sin(a), Math.cos(a)); // normalize
    this.angle += Math.sign(a) * Math.min(Math.abs(a), this.turnSpeed);
    // forward movement
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    // wrap around edges
    if(this.x < -20) this.x = W+20;
    if(this.x > W+20) this.x = -20;
    if(this.y < -20) this.y = H+20;
    if(this.y > H+20) this.y = -20;
    // reached target?
    if(dist(this, this.target) < 8) this.target = this.newTarget();

    // firing logic
    if(this.fireCooldown > 0) this.fireCooldown--;
    else {
      const enemy = this.findInFront();
      if(enemy){
        this.fireAt(enemy);
        this.fireCooldown = this.fireRate;
      }
    }
  }

  findInFront(){
    const VIEW_DIST = 140;
    const VIEW_ANGLE = Math.PI/6; // +/- 30 degrees
    let best = null;
    let bestD = Infinity;
    for(let t of tanks){
      if(t === this || !t.alive) continue;
      const d = dist(this,t);
      if(d > VIEW_DIST) continue;
      const a = Math.atan2(t.y - this.y, t.x - this.x);
      let da = Math.abs(Math.atan2(Math.sin(a - this.angle), Math.cos(a - this.angle)));
      if(da <= VIEW_ANGLE){
        if(d < bestD){ bestD = d; best = t; }
      }
    }
    return best;
  }

  fireAt(target){
    // instant hit: remove target
    if(!target || !target.alive) return;
    target.alive = false;
    // create a shot line effect
    shots.push({
      x1: this.x, y1: this.y,
      x2: target.x, y2: target.y,
      life: 12,
      color: this.color
    });
  }

  draw(){
    if(!this.alive) return;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    // triangle pointing to +x
    ctx.beginPath();
    ctx.moveTo(this.size, 0);
    ctx.lineTo(-this.size*0.6, this.size*0.6);
    ctx.lineTo(-this.size*0.6, -this.size*0.6);
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill();
    // small barrel line
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(this.size+6,0);
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = darken(this.color, -20);
    ctx.stroke();
    ctx.restore();
  }
}

function darken(hsl, change){
  // hsl string like "hsl(h,s%,l%)"
  const m = /hsl\((\d+),(\d+)%?,(\d+)%?\)/.exec(hsl);
  if(!m) return hsl;
  let h = +m[1], s=+m[2], l=+m[3];
  l = Math.max(0, Math.min(100, l+change));
  return `hsl(${h},${s}%,${l}%)`;
}

// init
for(let i=0;i<NUM;i++) tanks.push(new Tank());

// main loop
var time = performance.now();
function step(){
  var now = performance.now();
  // update
  for(let t of tanks) t.update();
  for(let i = shots.length-1; i>=0; i--){
    shots[i].life--;
    if(shots[i].life<=0) shots.splice(i,1);
  }
  // draw
  ctx.clearRect(0,0,W,H);
  // background grid subtle
  drawGrid();
  // draw shots behind small faint glow
  for(let s of shots){
    const alpha = s.life/12;
    ctx.beginPath();
    ctx.moveTo(s.x1, s.y1);
    ctx.lineTo(s.x2, s.y2);
    ctx.lineWidth = 2 + (1.5*alpha);
    ctx.strokeStyle = addAlpha(s.color, 0.9*alpha);
    ctx.stroke();
    // bright core
    ctx.beginPath();
    ctx.moveTo(s.x1, s.y1);
    ctx.lineTo(s.x2, s.y2);
    ctx.lineWidth = 1;
    ctx.strokeStyle = addAlpha('#fff', 0.5*alpha);
    ctx.stroke();
  }

  // draw tanks
  for(let t of tanks) t.draw();

  // optional UI: live count
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(6,6,140,28);
  ctx.fillStyle = '#fff';
  ctx.font = '13px monospace';
  const alive = tanks.filter(t=>t.alive).length;
  ctx.fillText(`Tanks: ${alive}/${NUM}`, 12, 24);
  var totalExecutionTime = performance.now() - now;
  if(performance.now() - time > 1){
    console.log("Frame execution time: "+ totalExecutionTime + "ms")
    time = performance.now();
  }
  console.log("frame calculation execution time:" + now + "ms");
  requestAnimationFrame(step);
}

function addAlpha(color, a){
  // accepts hsl or hex #rrggbb
  if(color.startsWith('hsl')) {
    return color.replace('hsl(', 'hsla(').replace(')', `,${a})`);
  }
  // hex
  const c = hexToRgb(color);
  return `rgba(${c.r},${c.g},${c.b},${a})`;
}
function hexToRgb(hex){
  hex = hex.replace('#','');
  if(hex.length===3) hex = hex.split('').map(x=>x+x).join('');
  const v = parseInt(hex,16);
  return {r:(v>>16)&255, g:(v>>8)&255, b:v&255};
}

function drawGrid(){
  ctx.save();
  ctx.globalAlpha = 0.05;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  const step = 64;
  for(let x=0;x<=W;x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0;y<=H;y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();
}

// click to add random target to nearest tank
canvas.addEventListener('click', (e)=>{
  const r = canvas.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (canvas.width / r.width);
  const my = (e.clientY - r.top) * (canvas.height / r.height);
  // find nearest alive tank
  let best = null, bd = Infinity;
  for(let t of tanks){
    if(!t.alive) continue;
    const d = Math.hypot(t.x-mx, t.y-my);
    if(d<bd){ bd=d; best=t; }
  }
  if(best) best.target = {x: mx, y: my};
});

// small keyboard controls: P pause/resume, R respawn dead
let paused = false;
window.addEventListener('keydown', (e)=>{
  if(e.key === 'p' || e.key === 'P') paused = !paused;
  if(e.key === 'r' || e.key === 'R'){ // respawn dead
    for(let t of tanks) if(!t.alive) {
      Object.assign(t, new Tank());
      // keep same array slot id
    }
  }
});

(function loop(){
  if(!paused) step();
  else requestAnimationFrame(loop);
})();

</script>
</body>
</html>


