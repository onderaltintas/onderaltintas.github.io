<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Goblin Savaşı</title>
<style>
  body { 
    margin:0; 
    background:#fff; 
    overflow: hidden;
  }
  canvas { 
    background:#fff; 
    display:block; 
    width: 100vw; 
    height: 100vh; 
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Kanvas boyutunu ekran boyutuna ayarla
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Pencere boyutu değiştiğinde kanvas boyutunu güncelle
window.addEventListener('resize', function() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

const spriteSheet = new Image();
spriteSheet.src = "sprites.png"; // 6144x1024 PNG

const goblins = [];
const spriteVariants = [];
const bullets = [];

class Goblin {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    // Tüm yönleri içeren olası hareket vektörleri
    const directions = [
      [-1, 0],  // Batı
      [-1, -1], // Kuzeybatı
      [0, -1],  // Kuzey
      [1, -1],  // Kuzeydoğu
      [1, 0],   // Doğu
      [1, 1],   // Güneydoğu
      [0, 1],   // Güney
      [-1, 1]   // Güneybatı
    ];
    const randomDir = directions[Math.floor(Math.random() * directions.length)];
    this.dirX = randomDir[0];
    this.dirY = randomDir[1];
    this.speed = 1.5;
    this.frame = 0;
    this.frameTick = Math.floor(Math.random() * 10); // Rastgele başlangıç delay'ı
    this.fireCooldown = Math.floor(Math.random() * 120); // Rastgele ateşleme delay'ı
    this.variant = Math.floor(Math.random() * 8); // 8 varyant olduğu için
    
    // Yeni özellikler
    this.state = "walking"; // walking, attacking, dying, idle
    this.animationFrame = 0;
    this.animationTick = 0;
    this.health = 100; // 5 atışta ölecek (her atış 20 hasar)
    
    // Animasyon varyantları
    this.walkType = Math.random() < 0.5 ? 0 : 1; // 0: yürüme1 (5-12), 1: yürüme2 (13-20)
    this.deathType = Math.random() < 0.5 ? 0 : 1; // 0: ölüm1 (34-39), 1: ölüm2 (40-47)
    
    // Durma süresi
    this.idleTimer = 0;
    this.idleDuration = 60 + Math.floor(Math.random() * 120); // 1-3 saniye arası
  }

  getDirectionIndex() {
    // Mevcut yöne göre indeks döndür
    if (this.dirX === -1 && this.dirY === 0) return 0; // Batı
    if (this.dirX === -1 && this.dirY === -1) return 1; // Kuzeybatı
    if (this.dirX === 0 && this.dirY === -1) return 2; // Kuzey
    if (this.dirX === 1 && this.dirY === -1) return 3; // Kuzeydoğu
    if (this.dirX === 1 && this.dirY === 0) return 4; // Doğu
    if (this.dirX === 1 && this.dirY === 1) return 5; // Güneydoğu
    if (this.dirX === 0 && this.dirY === 1) return 6; // Güney
    if (this.dirX === -1 && this.dirY === 1) return 7; // Güneybatı
    return 6; // Varsayılan Güney
  }
  
  getNeighborDirections() {
    const currentDir = this.getDirectionIndex();
    // Mevcut yöne göre komşu yönleri döndür
    switch(currentDir) {
      case 0: return [7, 1]; // Batı -> Güneybatı, Kuzeybatı
      case 1: return [0, 2]; // Kuzeybatı -> Batı, Kuzey
      case 2: return [1, 3]; // Kuzey -> Kuzeybatı, Kuzeydoğu
      case 3: return [2, 4]; // Kuzeydoğu -> Kuzey, Doğu
      case 4: return [3, 5]; // Doğu -> Kuzeydoğu, Güneydoğu
      case 5: return [4, 6]; // Güneydoğu -> Doğu, Güney
      case 6: return [5, 7]; // Güney -> Güneydoğu, Güneybatı
      case 7: return [6, 0]; // Güneybatı -> Güney, Batı
      default: return [0, 1];
    }
  }
  
  changeToNeighborDirection() {
    const neighbors = this.getNeighborDirections();
    const newDirIndex = neighbors[Math.floor(Math.random() * neighbors.length)];
    
    // Yön indeksini vektöre çevir
    switch(newDirIndex) {
      case 0: this.dirX = -1; this.dirY = 0; break;
      case 1: this.dirX = -1; this.dirY = -1; break;
      case 2: this.dirX = 0; this.dirY = -1; break;
      case 3: this.dirX = 1; this.dirY = -1; break;
      case 4: this.dirX = 1; this.dirY = 0; break;
      case 5: this.dirX = 1; this.dirY = 1; break;
      case 6: this.dirX = 0; this.dirY = 1; break;
      case 7: this.dirX = -1; this.dirY = 1; break;
    }
  }

  update() {
    // Eğer ölüyorsa sadece animasyonu güncelle
    if (this.state === "dying") {
      this.animationTick++;
      if (this.animationTick > 15) { // Ölme animasyonu daha yavaş
        this.animationFrame++;
        this.animationTick = 0;
        
        // Ölme animasyonu tamamlandı mı?
        const deathFrames = this.deathType === 0 ? 6 : 8;
        if (this.animationFrame >= deathFrames) {
          // Goblin'i tamamen kaldır
          const idx = goblins.indexOf(this);
          if (idx > -1) goblins.splice(idx, 1);
        }
      }
      return; // Ölme animasyonunda hareket etme
    }
    
    // Saldırı animasyonu
    if (this.state === "attacking") {
      this.animationTick++;
      if (this.animationTick > 10) {
        this.animationFrame++;
        this.animationTick = 0;
        
        // Saldırı animasyonu tamamlandı mı? (4 kare)
        if (this.animationFrame >= 4) {
          this.state = "walking";
          this.animationFrame = 0;
        }
      }
      return; // Saldırı sırasında hareket etme
    }
    
    // Durma animasyonu
    if (this.state === "idle") {
      this.idleTimer++;
      this.animationTick++;
      
      // Durma animasyonu kareleri
      if (this.animationTick > 15) {
        this.animationFrame = (this.animationFrame + 1) % 4;
        this.animationTick = 0;
      }
      
      // Durma süresi doldu mu?
      if (this.idleTimer >= this.idleDuration) {
        this.state = "walking";
        this.idleTimer = 0;
        this.idleDuration = 60 + Math.floor(Math.random() * 120); // Yeni durma süresi
      }
      
      return;
    }

    // Normal yürüme durumu
    if (this.state === "walking") {
      // Rastgele durma olasılığı
      if (Math.random() < 0.005) {
        this.state = "idle";
        this.animationFrame = 0;
        this.animationTick = 0;
        return;
      }
      
      // Rastgele yön değiştirme olasılığı - sadece komşu yönlere
      if (Math.random() < 0.01) {
        this.changeToNeighborDirection();
      }

      this.x += this.dirX * this.speed;
      this.y += this.dirY * this.speed;

      // Sınır kontrolü - duvara çarpınca rastgele yön değiştir
      if (this.x < 0) {
        this.dirX = 1;
        this.x = 0;
      }
      if (this.x > canvas.width) {
        this.dirX = -1;
        this.x = canvas.width;
      }
      if (this.y < 0) {
        this.dirY = 1;
        this.y = 0;
      }
      if (this.y > canvas.height) {
        this.dirY = -1;
        this.y = canvas.height;
      }

      this.frameTick++;
      if (this.frameTick > 10) {
        this.frame = (this.frame + 1) % 8;
        this.frameTick = 0;
      }

      if (this.fireCooldown > 0) this.fireCooldown--;

      if (this.fireCooldown === 0) {
        const target = this.findTarget();
        if (target) {
          this.shoot(target);
          this.fireCooldown = 120 + Math.floor(Math.random() * 60); // Rastgele ateşleme aralığı
        }
      }
    }
  }

  findTarget() {
    for (let g of goblins) {
      if (g !== this && g.state !== "dying") {
        const dx = g.x - this.x;
        const dy = g.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Yön kontrolü - hedef goblin'in mevcut yön doğrultusunda olup olmadığına bak
        const dotProduct = this.dirX * dx + this.dirY * dy;
        if (dotProduct > 0 && distance < 150) {
          return g;
        }
      }
    }
    return null;
  }

  shoot(target) {
    // Saldırı animasyonunu başlat
    this.state = "attacking";
    this.animationFrame = 0;
    this.animationTick = 0;
    
    // Mermi oluştur - Bullet sınıfını kullan
    bullets.push(new Bullet(this.x, this.y, target.x, target.y, target, this));
  }
  
  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0 && this.state !== "dying") {
      this.state = "dying";
      this.animationFrame = 0;
      this.animationTick = 0;
    }
  }

  draw(ctx) {
    const spriteWidth = 128;
    const spriteHeight = 128;
    const dir = this.getDirectionIndex();
    let frame;
    
    if (this.state === "dying") {
      // Ölme animasyonu: iki farklı tür
      if (this.deathType === 0) {
        // Ölüm1: 34-39 (6 kare)
        frame = 34 + this.animationFrame;
      } else {
        // Ölüm2: 40-47 (8 kare)
        frame = 40 + this.animationFrame;
      }
    } else if (this.state === "attacking") {
      // Saldırı animasyonu: 20-23 (4 kare)
      frame = 20 + this.animationFrame;
    } else if (this.state === "idle") {
      // Durma animasyonu: 0-3 (4 kare)
      frame = this.animationFrame;
    } else {
      // Yürüme animasyonu: iki farklı tür
      if (this.walkType === 0) {
        // Yürüme1: 5-12 (8 kare)
        frame = 5 + this.frame;
      } else {
        // Yürüme2: 13-20 (8 kare)
        frame = 13 + this.frame;
      }
    }

    ctx.drawImage(
      spriteVariants[this.variant],
      frame * spriteWidth, dir * spriteHeight, spriteWidth, spriteHeight,
      this.x - 64, this.y - 64, 128, 128  // Sprite'ı merkeze göre çiz
    );
    
    // Sağlık çubuğu (isteğe bağlı)
    if (this.state !== "dying") {
      ctx.fillStyle = "red";
      ctx.fillRect(this.x - 32, this.y - 80, 64, 5);
      ctx.fillStyle = "green";
      ctx.fillRect(this.x - 32, this.y - 80, 64 * (this.health / 100), 5);
    }
  }
}

class Bullet {
  constructor(x, y, targetX, targetY, target, shooter) {
    this.x = x;
    this.y = y;
    this.targetX = targetX;
    this.targetY = targetY;
    this.target = target;
    this.shooter = shooter;
    this.progress = 0;
    this.speed = 0.05;
  }
  
  update() {
    this.progress += this.speed;
    
    // Mermi hedefe ulaştı mı?
    if (this.progress >= 1) {
      // Hedefe hasar ver (20 hasar - 5 atışta ölecek)
      if (goblins.includes(this.target) && this.target.state !== "dying") {
        this.target.takeDamage(20);
      }
      
      // Mermiyi kaldır
      const idx = bullets.indexOf(this);
      if (idx > -1) bullets.splice(idx, 1);
    }
  }
  
  draw(ctx) {
    const currentX = this.x + (this.targetX - this.x) * this.progress;
    const currentY = this.y + (this.targetY - this.y) * this.progress;
    
    ctx.beginPath();
    ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
    ctx.fillStyle = "red";
    ctx.fill();
    
    // Mermi izi
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(currentX, currentY);
    ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function loop() {
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let g of goblins) g.update();
  for (let b of bullets) b.update();
  
  for (let g of goblins) g.draw(ctx);
  for (let b of bullets) b.draw(ctx);

  requestAnimationFrame(loop);
}

spriteSheet.onload = () => {
  // 8 hue varyantı hazırla
  for (let i = 0; i < 8; i++) {
    const off = document.createElement("canvas");
    off.width = spriteSheet.width;
    off.height = spriteSheet.height;
    const offCtx = off.getContext("2d");
    offCtx.filter = `hue-rotate(${i * 45}deg)`;
    offCtx.drawImage(spriteSheet, 0, 0);
    offCtx.filter = "none";
    spriteVariants.push(off);
  }

  // Goblin'leri oluştur
  for (let i = 0; i < 250; i++) {
    goblins.push(new Goblin(Math.random() * canvas.width, Math.random() * canvas.height));
  }

  loop();
};
</script>
</body>
</html>