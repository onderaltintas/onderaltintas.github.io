<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Goblin Savaşı - WebGL</title>
<style>
  body { 
    margin:0; 
    background:#ccc; 
    overflow: hidden;
  }
  canvas { 
    background:#ddd; 
    display:block; 
    width: 100vw; 
    height: 100vh; 
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// Ayarlar
const SHOW_HEALTH_BARS = true;
const NUMBER_OF_GOBLINS = 150;

const canvas = document.getElementById("gameCanvas");
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  alert('WebGL desteklenmiyor!');
}

// Kanvas boyutunu ayarla
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// WebGL viewport'u ayarla
gl.viewport(0, 0, canvas.width, canvas.height);

const goblins = [];
const bullets = [];

// WebGL shader'ları
const vertexShaderSource = `
  attribute vec2 aPosition;
  attribute vec2 aTexCoord;
  varying vec2 vTexCoord;
  
  void main() {
    gl_Position = vec4(aPosition, 0.0, 1.0);
    vTexCoord = aTexCoord;
  }
`;

const fragmentShaderSource = `
  precision mediump float;
  varying vec2 vTexCoord;
  uniform sampler2D uTexture;
  uniform vec4 uColor;
  
  void main() {
    vec4 texColor = texture2D(uTexture, vTexCoord);
    if (texColor.a < 0.1) {
      discard;
    }
    gl_FragColor = texColor * uColor;
  }
`;

// Shader'ları derleme fonksiyonu
function createShader(gl, source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader derleme hatası:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

// Program oluşturma
const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
const fragmentShader = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error('Program link hatası:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

// Buffer'ları oluştur
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [
  -1, -1,
  1, -1,
  -1, 1,
  1, 1
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const texCoordBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
const texCoords = [
  0, 1,
  1, 1,
  0, 0,
  1, 0
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

// Attribute'ları bağla
const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPosition);
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

const aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
gl.enableVertexAttribArray(aTexCoord);
gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

// Uniform'lar
const uTexture = gl.getUniformLocation(program, 'uTexture');
const uColor = gl.getUniformLocation(program, 'uColor');

// Texture oluştur
const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

// Sprite sheet yükle
const spriteSheet = new Image();
spriteSheet.onload = function() {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, spriteSheet);
  
  // Goblin'leri oluştur
  for (let i = 0; i < NUMBER_OF_GOBLINS; i++) {
    goblins.push(new Goblin(Math.random() * canvas.width, Math.random() * canvas.height));
  }
  
  // Oyun döngüsünü başlat
  loop();
};
spriteSheet.src = "sprites.png";

class Goblin {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    const directions = [
      [-1, 0], [-1, -1], [0, -1], [1, -1],
      [1, 0], [1, 1], [0, 1], [-1, 1]
    ];
    const randomDir = directions[Math.floor(Math.random() * directions.length)];
    this.dirX = randomDir[0];
    this.dirY = randomDir[1];
    this.speed = 1.5;
    this.frame = 0;
    this.frameTick = Math.floor(Math.random() * 10);
    this.fireCooldown = Math.floor(Math.random() * 120);
    this.variant = Math.floor(Math.random() * 8);
    
    this.state = "walking";
    this.animationFrame = 0;
    this.animationTick = 0;
    this.health = 100;
    
    this.walkType = Math.random() < 0.5 ? 0 : 1;
    this.deathType = Math.random() < 0.5 ? 0 : 1;
    
    this.idleTimer = 0;
    this.idleDuration = 60 + Math.floor(Math.random() * 120);
  }

  getDirectionIndex() {
    if (this.dirX === -1 && this.dirY === 0) return 0;
    if (this.dirX === -1 && this.dirY === -1) return 1;
    if (this.dirX === 0 && this.dirY === -1) return 2;
    if (this.dirX === 1 && this.dirY === -1) return 3;
    if (this.dirX === 1 && this.dirY === 0) return 4;
    if (this.dirX === 1 && this.dirY === 1) return 5;
    if (this.dirX === 0 && this.dirY === 1) return 6;
    if (this.dirX === -1 && this.dirY === 1) return 7;
    return 6;
  }
  
  getNeighborDirections() {
    const currentDir = this.getDirectionIndex();
    switch(currentDir) {
      case 0: return [7, 1];
      case 1: return [0, 2];
      case 2: return [1, 3];
      case 3: return [2, 4];
      case 4: return [3, 5];
      case 5: return [4, 6];
      case 6: return [5, 7];
      case 7: return [6, 0];
      default: return [0, 1];
    }
  }
  
  changeToNeighborDirection() {
    const neighbors = this.getNeighborDirections();
    const newDirIndex = neighbors[Math.floor(Math.random() * neighbors.length)];
    
    switch(newDirIndex) {
      case 0: this.dirX = -1; this.dirY = 0; break;
      case 1: this.dirX = -1; this.dirY = -1; break;
      case 2: this.dirX = 0; this.dirY = -1; break;
      case 3: this.dirX = 1; this.dirY = -1; break;
      case 4: this.dirX = 1; this.dirY = 0; break;
      case 5: this.dirX = 1; this.dirY = 1; break;
      case 6: this.dirX = 0; this.dirY = 1; break;
      case 7: this.dirX = -1; this.dirY = 1; break;
    }
  }

  update() {
    if (this.state === "dying") {
      this.animationTick++;
      if (this.animationTick > 15) {
        this.animationFrame++;
        this.animationTick = 0;
        
        const deathFrames = this.deathType === 0 ? 6 : 8;
        if (this.animationFrame >= deathFrames) {
          const idx = goblins.indexOf(this);
          if (idx > -1) goblins.splice(idx, 1);
        }
      }
      return;
    }
    
    if (this.state === "attacking") {
      this.animationTick++;
      if (this.animationTick > 10) {
        this.animationFrame++;
        this.animationTick = 0;
        
        if (this.animationFrame >= 4) {
          this.state = "walking";
          this.animationFrame = 0;
        }
      }
      return;
    }
    
    if (this.state === "idle") {
      this.idleTimer++;
      this.animationTick++;
      
      if (this.animationTick > 15) {
        this.animationFrame = (this.animationFrame + 1) % 4;
        this.animationTick = 0;
      }
      
      if (this.idleTimer >= this.idleDuration) {
        this.state = "walking";
        this.idleTimer = 0;
        this.idleDuration = 60 + Math.floor(Math.random() * 120);
      }
      
      return;
    }

    if (this.state === "walking") {
      if (Math.random() < 0.005) {
        this.state = "idle";
        this.animationFrame = 0;
        this.animationTick = 0;
        return;
      }
      
      if (Math.random() < 0.01) {
        this.changeToNeighborDirection();
      }

      this.x += this.dirX * this.speed;
      this.y += this.dirY * this.speed;

      if (this.x < 0) {
        this.dirX = 1;
        this.x = 0;
      }
      if (this.x > canvas.width) {
        this.dirX = -1;
        this.x = canvas.width;
      }
      if (this.y < 0) {
        this.dirY = 1;
        this.y = 0;
      }
      if (this.y > canvas.height) {
        this.dirY = -1;
        this.y = canvas.height;
      }

      this.frameTick++;
      if (this.frameTick > 10) {
        this.frame = (this.frame + 1) % 8;
        this.frameTick = 0;
      }

      if (this.fireCooldown > 0) this.fireCooldown--;

      if (this.fireCooldown === 0) {
        const target = this.findTarget();
        if (target) {
          this.shoot(target);
          this.fireCooldown = 120 + Math.floor(Math.random() * 60);
        }
      }
    }
  }

  findTarget() {
    for (let g of goblins) {
      if (g !== this && g.state !== "dying") {
        const dx = g.x - this.x;
        const dy = g.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const dotProduct = this.dirX * dx + this.dirY * dy;
        if (dotProduct > 0 && distance < 150) {
          return g;
        }
      }
    }
    return null;
  }

  shoot(target) {
    this.state = "attacking";
    this.animationFrame = 0;
    this.animationTick = 0;
    
    bullets.push(new Bullet(this.x, this.y, target.x, target.y, target, this));
  }
  
  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0 && this.state !== "dying") {
      this.state = "dying";
      this.animationFrame = 0;
      this.animationTick = 0;
    }
  }

  draw() {
    const spriteWidth = 128;
    const spriteHeight = 128;
    const dir = this.getDirectionIndex();
    let frame;
    
    if (this.state === "dying") {
      if (this.deathType === 0) {
        frame = 34 + this.animationFrame;
      } else {
        frame = 40 + this.animationFrame;
      }
    } else if (this.state === "attacking") {
      frame = 20 + this.animationFrame;
    } else if (this.state === "idle") {
      frame = this.animationFrame;
    } else {
      if (this.walkType === 0) {
        frame = 5 + this.frame;
      } else {
        frame = 13 + this.frame;
      }
    }

    // WebGL ile sprite çizimi
    const scaleX = 128 / canvas.width;
    const scaleY = 128 / canvas.height;
    const posX = (this.x / canvas.width) * 2 - 1;
    const posY = 1 - (this.y / canvas.height) * 2;

    const texX = frame * spriteWidth / spriteSheet.width;
    const texY = dir * spriteHeight / spriteSheet.height;
    const texWidth = spriteWidth / spriteSheet.width;
    const texHeight = spriteHeight / spriteSheet.height;

    // Sprite çizimi için transform
    drawSprite(posX, posY, scaleX, scaleY, texX, texY, texWidth, texHeight);
    
    // Health bar (2D canvas kullanarak)
    if (SHOW_HEALTH_BARS && this.state !== "dying") {
      drawHealthBar(this.x, this.y, this.health);
    }
  }
}

class Bullet {
  constructor(x, y, targetX, targetY, target, shooter) {
    this.x = x;
    this.y = y;
    this.targetX = targetX;
    this.targetY = targetY;
    this.target = target;
    this.shooter = shooter;
    this.progress = 0;
    this.speed = 0.05;
  }
  
  update() {
    this.progress += this.speed;
    
    if (this.progress >= 1) {
      if (goblins.includes(this.target) && this.target.state !== "dying") {
        this.target.takeDamage(20);
      }
      
      const idx = bullets.indexOf(this);
      if (idx > -1) bullets.splice(idx, 1);
    }
  }
  
  draw() {
    const currentX = this.x + (this.targetX - this.x) * this.progress;
    const currentY = this.y + (this.targetY - this.y) * this.progress;
    
    drawBullet(this.x, this.y, currentX, currentY);
  }
}

// WebGL çizim yardımcı fonksiyonları
function drawSprite(x, y, scaleX, scaleY, texX, texY, texWidth, texHeight) {
  // Texture koordinatlarını güncelle
  const customTexCoords = [
    texX, texY + texHeight,
    texX + texWidth, texY + texHeight,
    texX, texY,
    texX + texWidth, texY
  ];
  
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(customTexCoords), gl.DYNAMIC_DRAW);
  
  // Transform uygula
  const transform = [
    scaleX, 0, 0, 0,
    0, scaleY, 0, 0,
    0, 0, 1, 0,
    x, y, 0, 1
  ];
  
  // Basit çizim - gerçek uygulamada transform matrix kullanılmalı
  gl.uniform4f(uColor, 1, 1, 1, 1);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// Health bar ve mermi çizimi için 2D canvas kullanıyoruz
const healthBarCanvas = document.createElement('canvas');
healthBarCanvas.width = canvas.width;
healthBarCanvas.height = canvas.height;
const healthBarCtx = healthBarCanvas.getContext('2d');

function drawHealthBar(x, y, health) {
  healthBarCtx.fillStyle = "red";
  healthBarCtx.fillRect(x - 32, y - 80, 64, 5);
  healthBarCtx.fillStyle = "green";
  healthBarCtx.fillRect(x - 32, y - 80, 64 * (health / 100), 5);
}

function drawBullet(startX, startY, endX, endY) {
  healthBarCtx.beginPath();
  healthBarCtx.arc(endX, endY, 3, 0, Math.PI * 2);
  healthBarCtx.fillStyle = "red";
  healthBarCtx.fill();
  
  healthBarCtx.beginPath();
  healthBarCtx.moveTo(startX, startY);
  healthBarCtx.lineTo(endX, endY);
  healthBarCtx.strokeStyle = "rgba(255, 0, 0, 0.3)";
  healthBarCtx.lineWidth = 2;
  healthBarCtx.stroke();
}

function loop() {
  // Arkaplanı temizle
  gl.clearColor(0.86, 0.86, 0.86, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  // Health bar canvas'ını temizle
  healthBarCtx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Texture'ı bağla
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(uTexture, 0);
  
  // Goblin ve mermileri güncelle
  for (let g of goblins) g.update();
  for (let b of bullets) b.update();
  
  // Goblin ve mermileri çiz
  for (let g of goblins) g.draw();
  for (let b of bullets) b.draw();
  
  // Health bar'ları ve mermileri WebGL canvas'ına çiz
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, healthBarCanvas);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.disable(gl.BLEND);

  requestAnimationFrame(loop);
}

// Pencere boyutu değiştiğinde
window.addEventListener('resize', function() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  healthBarCanvas.width = canvas.width;
  healthBarCanvas.height = canvas.height;
});
</script>
</body>
</html>
